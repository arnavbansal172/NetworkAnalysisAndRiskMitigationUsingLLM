import logging
import ipaddress
from typing import Dict, Any, List, Optional, Set, Callable
from pathlib import Path

logger = logging.getLogger(__name__)

# standard severity levels
SEVERITY_CRITICAL = "Critical"
SEVERITY_HIGH = "High"
SEVERITY_MEDIUM = "Medium"
SEVERITY_LOW = "Low"
SEVERITY_INFO = "Informational"

# Mapped severity strings to numerical levels for sorting/comparison
SEVERITY_LEVELS = {
    SEVERITY_INFO: 1,
    SEVERITY_LOW: 2,
    SEVERITY_MEDIUM: 3,
    SEVERITY_HIGH: 4,
    SEVERITY_CRITICAL: 5
}

# Rule Class
class Rule:
    """Represents a single detection rule."""
    def __init__(self, rule_id: str, description: str, severity: str, check_func: Callable[[Dict[str, Any]], bool], mitigation: Optional[List[str]] = None):
        """
        Initializes a rule.

        Args:
            rule_id: A unique identifier for the rule.
            description: A human-readable description of what the rule detects.
            severity: The severity level (e.g., SEVERITY_HIGH).
            check_func: A callable function that takes packet features (dict)
                        and returns True if the rule matches, False otherwise.
            mitigation: Optional list of specific mitigation steps for this rule.
        """
        if severity not in SEVERITY_LEVELS:
            raise ValueError(f"Invalid severity level: {severity}. Use defined constants.")
        self.rule_id = rule_id
        self.description = description
        self.severity = severity
        self.check_func = check_func
        self.mitigation = mitigation if mitigation else []

    def check(self, features: Dict[str, Any]) -> bool:
        """Executes the rule's check function safely."""
        try:
            return self.check_func(features)
        except KeyError as ke:
             # Expected if a feature the rule needs isn't present (e.g., checking dst_port on non-TCP/UDP)
             # logger.debug(f"Rule {self.rule_id} skipped: Missing feature {ke}.")
             return False
        except Exception as e:
            logger.error(f"Error executing rule check function for {self.rule_id}: {e}", exc_info=False)
            return False # Treat errors as non-matches

    def generate_finding(self, features: Dict[str, Any]) -> Dict[str, Any]:
        """Generates a standardized finding dictionary if the rule matches."""
        # Default mitigation if none provided specifically for the rule
        default_mitigation = [
            f"Investigate traffic matching rule '{self.rule_id}' involving source {features.get('src_ip','<IP>')}:{features.get('src_port','<Port>')} and destination {features.get('dst_ip','<IP>')}:{features.get('dst_port','<Port>')}.",
            "Validate the detection and consult security policies for appropriate response actions.",
            "Refer to rule documentation or security knowledge base for specific mitigation procedures related to this detection."
        ]
        mitigation_steps = self.mitigation if self.mitigation else default_mitigation

        return {
            "vulnerability_type": f"Rule Detection ({self.rule_id})",
            "severity": self.severity,
            "description": self.description,
            "mitigation_steps": mitigation_steps,
            "rule_id": self.rule_id # Include rule ID for easier lookup/reference
        }


# --- Rule Engine Class ---
class RuleEngine:
    """Manages and applies a set of detection rules."""
    def __init__(self, load_defaults: bool = True):
        self.rules: List[Rule] = []
        # Consider loading external resources here if needed by rules
        self._malicious_ips: Set[str] = set()
        self._malicious_domains: Set[str] = set()

        if load_defaults:
            self._load_default_rules()

    def _load_default_rules(self):
        """Loads a predefined set of example rules."""
        logger.info("Loading default rules into engine...")

        # --- Define Rules ---

        # Example: Update malicious IPs (replace with loading from a file/feed)
        self._malicious_ips = {"198.51.100.1", "203.0.113.5", "192.0.2.200"}
        self._malicious_domains = {"malware-domain.example", "phishing-site.example"}

        # Rule 1: Known Malicious IP
        def check_malicious_ip(f: Dict[str, Any]) -> bool:
            # Use isdisjoint for efficient set intersection check
            return not self._malicious_ips.isdisjoint({f.get("src_ip"), f.get("dst_ip")})
        self.add_rule(Rule(
            rule_id="MAL_IP_BLOCKLIST",
            description="Traffic involves an IP address present on a known malicious blocklist.",
            severity=SEVERITY_HIGH,
            check_func=check_malicious_ip,
            mitigation=[
                "Block the offending IP address ({matched_ip}) at the perimeter firewall.", # Placeholder for matched IP
                "Investigate internal hosts communicating with the malicious IP for compromise.",
                "Update blocklist source if applicable."
            ] # Example specific mitigation
        ))

        # Rule 2: Known Malicious Domain (requires DNS info extraction - placeholder)
        def check_malicious_domain(f: Dict[str, Any]) -> bool:
            # This requires features['dns_query_name'] or similar from feature_extractor
            qname = f.get("dns_query_name")
            return qname is not None and qname in self._malicious_domains
        self.add_rule(Rule(
            rule_id="MAL_DOMAIN_DNS",
            description="DNS query detected for a known malicious domain.",
            severity=SEVERITY_HIGH,
            check_func=check_malicious_domain,
            mitigation=[
                 "Block the domain ({matched_domain}) at the DNS resolver/firewall.",
                 "Identify the internal host ({src_ip}) making the query and investigate for malware.",
                 "Review logs for previous queries to this or related domains."
            ]
        ))

        # Rule 3: Insecure Protocol (Telnet)
        def check_telnet(f: Dict[str, Any]) -> bool:
            return f.get("protocol") == "TCP" and f.get("dst_port") == 23
        self.add_rule(Rule(
            rule_id="INSECURE_TELNET",
            description="Unencrypted Telnet traffic detected (port 23).",
            severity=SEVERITY_MEDIUM,
            check_func=check_telnet,
            mitigation=[
                "Identify the source and destination systems using Telnet.",
                "Disable the Telnet service on the server if possible.",
                "Migrate users/applications to use SSH or other secure protocols.",
                "Restrict Telnet access via firewall rules if it cannot be disabled."
            ]
        ))

        # Rule 4: Insecure Protocol (FTP Control)
        def check_ftp(f: Dict[str, Any]) -> bool:
            return f.get("protocol") == "TCP" and f.get("dst_port") == 21
        self.add_rule(Rule(
             rule_id="INSECURE_FTP",
             description="Unencrypted FTP control connection detected (port 21).",
             severity=SEVERITY_MEDIUM,
             check_func=check_ftp,
             mitigation=[
                 "Identify systems using FTP.",
                 "Migrate users/applications to use SFTP, FTPS, or SCP.",
                 "Restrict FTP access via firewalls if it cannot be disabled.",
                 "Educate users about the risks of transmitting credentials over FTP."
             ]
        ))

        # Rule 5: Basic Payload Signature (Log4Shell - JNDI in common places)
        # This is illustrative; real detection is much more complex.
        log4shell_pattern = b"${jndi:" # Check bytes directly
        def check_log4shell_basic(f: Dict[str, Any]) -> bool:
            payload = f.get("payload_bytes") # Expect raw bytes from feature extractor
            return payload is not None and log4shell_pattern in payload
        self.add_rule(Rule(
            rule_id="SIG_LOG4SHELL_JNDI",
            description="Potential Log4Shell (CVE-2021-44228) JNDI pattern detected in payload.",
            severity=SEVERITY_CRITICAL,
            check_func=check_log4shell_basic,
            mitigation=[
                "Block source IP at WAF/Firewall immediately.",
                "Isolate the destination server and investigate for compromise.",
                "Urgently patch or mitigate Log4j on the affected server.",
                "Ensure WAF/IPS signatures for Log4Shell are enabled and effective."
            ]
        ))

        # Rule 6: SMB Scan (SYN to port 445)
        def check_smb_scan(f: Dict[str, Any]) -> bool:
             flags = f.get("tcp_flags", "")
             return (f.get("protocol") == "TCP" and
                     f.get("dst_port") == 445 and
                     "S" in flags and # SYN flag is set
                     "A" not in flags) # ACK flag is NOT set (it's not SYN-ACK)
        self.add_rule(Rule(
             rule_id="SCAN_SMB_SYN",
             description="Potential SMB scan detected (TCP SYN packet to port 445).",
             severity=SEVERITY_LOW,
             check_func=check_smb_scan,
             mitigation=[
                 "Monitor the source host ({src_ip}) for further scanning or connection attempts.",
                 "Ensure destination hosts are patched against SMB vulnerabilities (e.g., MS17-010).",
                 "Verify internal network segmentation restricts unnecessary SMB access.",
             ]
        ))

        # Rule 7: RDP Scan (SYN to port 3389)
        def check_rdp_scan(f: Dict[str, Any]) -> bool:
             flags = f.get("tcp_flags", "")
             return (f.get("protocol") == "TCP" and
                     f.get("dst_port") == 3389 and
                     "S" in flags and "A" not in flags)
        self.add_rule(Rule(
             rule_id="SCAN_RDP_SYN",
             description="Potential RDP scan detected (TCP SYN packet to port 3389).",
             severity=SEVERITY_LOW,
             check_func=check_rdp_scan,
             mitigation=[
                 "Monitor the source host ({src_ip}) for further RDP scanning or login attempts.",
                 "Ensure RDP access is restricted to authorized sources via firewall rules.",
                 "Enable Network Level Authentication (NLA) on RDP servers.",
                 "Use strong passwords and consider multi-factor authentication for RDP.",
                 "Review RDP logs on destination hosts for failed login attempts."
             ]
        ))

        # Add more rules here (e.g., SSH bruteforce attempts, specific malware signatures, etc.)

        logger.info(f"Loaded {len(self.rules)} default rules.")


    def add_rule(self, rule: Rule):
        """Adds a rule object to the engine."""
        if not isinstance(rule, Rule):
            raise TypeError("Can only add Rule objects to the engine.")
        logger.debug(f"Adding rule: {rule.rule_id}")
        self.rules.append(rule)

    def load_rules_from_file(self, filepath: Path):
        """Placeholder: Loads rules from an external file (e.g., YAML, JSON)."""
        # TODO: Implement logic to parse rules from a file format
        logger.warning(f"Loading rules from file ({filepath}) is not yet implemented.")
        pass

    def update_blocklists(self, ips: Set[str] = None, domains: Set[str] = None):
         """Updates internal blocklists (can be called periodically)."""
         if ips is not None:
              self._malicious_ips.update(ips)
              logger.info(f"Updated malicious IPs. Total: {len(self._malicious_ips)}")
         if domains is not None:
              self._malicious_domains.update(domains)
              logger.info(f"Updated malicious domains. Total: {len(self._malicious_domains)}")


    def check_packet(self, features: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Checks packet features against loaded rules, returning the first match.

        Args:
            features: Dictionary of extracted packet features. Expected keys depend on rules.

        Returns:
            A finding dictionary generated by the matched rule, or None if no rule matches.
        """
        if not features:
            return None

        for rule in self.rules:
            if rule.check(features):
                # Rule matched, generate and return the finding
                finding = rule.generate_finding(features)
                # Add matched IP/domain to finding description/mitigation if rule supports it
                # (This requires rule check_funcs to potentially return match details or modify finding)
                # Example (simplistic):
                if rule.rule_id == "MAL_IP_BLOCKLIST":
                     matched_ip = features.get("src_ip") if features.get("src_ip") in self._malicious_ips else features.get("dst_ip")
                     finding["description"] = finding["description"].replace("{matched_ip}", str(matched_ip))
                     finding["mitigation_steps"] = [m.replace("{matched_ip}", str(matched_ip)) for m in finding["mitigation_steps"]]
                elif rule.rule_id == "MAL_DOMAIN_DNS":
                     matched_domain = features.get("dns_query_name")
                     finding["description"] = finding["description"].replace("{matched_domain}", str(matched_domain))
                     finding["mitigation_steps"] = [m.replace("{matched_domain}", str(matched_domain)).replace("{src_ip}", str(features.get("src_ip"))) for m in finding["mitigation_steps"]]

                logger.info(f"Rule MATCH: '{rule.rule_id}' severity '{rule.severity}' on packet (Src={features.get('src_ip')}, Dst={features.get('dst_ip')})")
                return finding
        return None # No rules matched