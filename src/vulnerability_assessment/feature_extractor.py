import logging
import datetime
from typing import Dict, Any, Optional
# Import Scapy layers safely
try:
    from scapy.all import Packet, Ether, IP, IPv6, TCP, UDP, ICMP, DNS, DNSQR, DNSRR, Raw, fuzz, Scapy_Exception
    from scapy.layers.inet import IPerror, TCPerror, UDPerror, ICMPerror # For handling malformed packets
    from scapy.packet import Padding, NoPayload # To identify padding vs actual load
    from scapy.layers.inet6 import IPv6error # For handling malformed IPv6 packets
except ImportError:
     # This should not happen if requirements are met, but good practice
     raise ImportError("Scapy is required but not found. Please install it: pip install scapy")

logger = logging.getLogger(__name__)

MAX_PAYLOAD_SNIPPET_LEN = 128 # Max length of payload text snippet
MAX_PAYLOAD_BYTES_LEN = 256 # Max length of raw payload bytes to include

def _safe_payload_decode(payload_bytes: bytes) -> str:
    """Attempts to decode payload bytes, returning repr on failure."""
    try:
        # Use 'replace' to handle invalid UTF-8 sequences gracefully
        return payload_bytes.decode('utf-8', errors='replace')
    except Exception:
        # Fallback to representation of raw bytes if decode fails unexpectedly
        return repr(payload_bytes)

def extract_features_from_packet(
    packet: Packet,
    packet_number: int = 0,
    source_id: str = "unknown"
) -> Optional[Dict[str, Any]]:
    """
    Extracts key features from a Scapy packet for rule/LLM analysis.

    Args:
        packet: The Scapy Packet object.
        packet_number: Sequence identifier (e.g., from PCAP file).
        source_id: Identifier for the source (e.g., pcap filename, 'live_capture').

    Returns:
        A dictionary containing extracted features, or None if the packet
        is considered irrelevant (e.g., non-IP and not handled).
        Returns raw payload bytes as 'payload_bytes' and a decoded snippet
        as 'payload_snippet'.
    """
    if packet is None:
        return None

    features = {
        "timestamp": datetime.fromtimestamp(float(packet.time)).isoformat() + "Z",
        "packet_number": packet_number,
        "source": source_id,
        "length": len(packet),
        # Initialize core fields to None
        "src_mac": None, "dst_mac": None,
        "ip_version": None, "src_ip": None, "dst_ip": None, "protocol_num": None,
        "protocol": None, "src_port": None, "dst_port": None,
        "tcp_flags": None, "icmp_type": None, "icmp_code": None,
        "dns_query_name": None, "dns_response_ips": None,
        "payload_snippet": None, # Text snippet
        "payload_bytes": None, # Raw bytes (limited)
    }

    try:
        # --- Layer 2: Ethernet ---
        if Ether in packet:
            features["src_mac"] = packet[Ether].src
            features["dst_mac"] = packet[Ether].dst

        # --- Layer 3: IP ---
        ip_layer = None
        if IP in packet:
            ip_layer = packet[IP]
            features["ip_version"] = 4
        elif IPv6 in packet:
            ip_layer = packet[IPv6]
            features["ip_version"] = 6
        # Handle potential malformed IP layer from fuzzing etc.
        elif IPerror in packet or IPv6error in packet:
             logger.debug(f"Packet {packet_number}: Malformed IP layer detected. Extracting limited info.")
             # Try to extract basic info if possible, otherwise skip L3+
             if hasattr(packet, 'src'): features["src_ip"] = str(packet.src) # Best effort
             if hasattr(packet, 'dst'): features["dst_ip"] = str(packet.dst)
             features["protocol"] = "IP_Malformed"
             return features # Stop further processing for badly malformed IP

        else:
            # Not an IP packet (e.g., ARP, LLDP). Consider if specific handling is needed.
            # For now, we focus on IP-based vulnerabilities.
            # logger.debug(f"Packet {packet_number}: Not an IP packet ({packet.summary()[:50]}...). Skipping L3+ feature extraction.")
            # Could return basic L2 info if desired: return features
            return None # Ignore non-IP packets for this analysis focus

        # Extract common IP fields
        features["src_ip"] = ip_layer.src
        features["dst_ip"] = ip_layer.dst
        features["protocol_num"] = ip_layer.proto # Protocol number (e.g., 6=TCP, 17=UDP, 1=ICMP)

        # --- Layer 4: Transport ---
        transport_layer = None
        payload_bytes = b''

        if TCP in packet:
            transport_layer = packet[TCP]
            features["protocol"] = "TCP"
            features["src_port"] = transport_layer.sport
            features["dst_port"] = transport_layer.dport
            # Represent flags as a string (e.g., "S", "SA", "PA", "R")
            features["tcp_flags"] = str(transport_layer.flags)
            # Extract payload after TCP header
            if Raw in transport_layer:
                payload_bytes = transport_layer[Raw].load
            elif Padding in transport_layer: # Check for padding explicitly
                 payload_bytes = b'' # Treat padding as no real payload
            # Add checks for malformed TCP if needed (TCPerror)

        elif UDP in packet:
            transport_layer = packet[UDP]
            features["protocol"] = "UDP"
            features["src_port"] = transport_layer.sport
            features["dst_port"] = transport_layer.dport
            # Extract payload after UDP header
            if Raw in transport_layer:
                 payload_bytes = transport_layer[Raw].load
            elif Padding in transport_layer:
                 payload_bytes = b''
            # Add checks for malformed UDP if needed (UDPerror)

            # --- Layer 7 Example: DNS (over UDP) ---
            if DNS in packet and transport_layer.dport == 53 or transport_layer.sport == 53:
                dns_layer = packet[DNS]
                features["protocol"] = "DNS" # Be more specific than UDP
                try:
                    # Check for DNS Query Record (qr=0)
                    if dns_layer.qr == 0 and dns_layer.qdcount > 0 and isinstance(dns_layer.qd, DNSQR):
                        # Safely decode query name bytes
                        features["dns_query_name"] = dns_layer.qd.qname.decode('utf-8', errors='replace').rstrip('.') # Remove trailing dot
                    # Check for DNS Response Record (qr=1)
                    elif dns_layer.qr == 1 and dns_layer.ancount > 0:
                        response_ips = []
                        # Iterate through answer records (DNSRR)
                        current_rr = dns_layer.an
                        while current_rr and isinstance(current_rr, DNSRR):
                            # Check if it's an A record (IPv4) or AAAA record (IPv6)
                            if current_rr.type in [1, 28] and hasattr(current_rr, 'rdata'):
                                response_ips.append(str(current_rr.rdata))
                            # Move to the next answer record if linked list structure
                            if hasattr(current_rr, 'payload') and isinstance(current_rr.payload, DNSRR):
                                 current_rr = current_rr.payload
                            else:
                                 break # End of answers or unexpected structure
                        if response_ips:
                            features["dns_response_ips"] = response_ips
                except Exception as dns_e:
                    logger.warning(f"Packet {packet_number}: Error parsing DNS layer: {dns_e}")


        elif ICMP in packet:
            transport_layer = packet[ICMP]
            features["protocol"] = "ICMP"
            features["icmp_type"] = transport_layer.type
            features["icmp_code"] = transport_layer.code
            # Extract payload after ICMP header
            if Raw in transport_layer:
                 payload_bytes = transport_layer[Raw].load
            elif Padding in transport_layer:
                 payload_bytes = b''
            # Add checks for malformed ICMP if needed (ICMPerror)

        else:
            # Other IP protocols (e.g., GRE, ESP, OSPF - proto numbers 47, 50, 89)
            features["protocol"] = f"IP_Proto_{features['protocol_num']}"
            # Try to get payload directly from IP layer if no known transport layer recognized
            if hasattr(ip_layer, 'payload') and not isinstance(ip_layer.payload, (Padding, NoPayload)):
                 # Check if the payload is already bytes or needs conversion
                 if isinstance(ip_layer.payload, bytes):
                      payload_bytes = ip_layer.payload
                 elif hasattr(ip_layer.payload, 'original'): # Scapy often stores original bytes
                      payload_bytes = ip_layer.payload.original
                 elif hasattr(ip_layer.payload, 'load'): # Fallback if it has a load field
                      payload_bytes = bytes(ip_layer.payload.load)


        # --- Process Payload ---
        if payload_bytes:
            # Store limited raw bytes
            features["payload_bytes"] = payload_bytes[:MAX_PAYLOAD_BYTES_LEN]
            # Create decoded snippet
            snippet = _safe_payload_decode(payload_bytes[:MAX_PAYLOAD_SNIPPET_LEN])
            # Basic sanitization of snippet for display/prompt (remove null bytes)
            features["payload_snippet"] = snippet.replace('\x00', '.')
        else:
            features["payload_bytes"] = b''
            features["payload_snippet"] = ""


        # Optional: Add flow tracking logic here later if needed
        # features["flow_id"] = generate_flow_id(...) # e.g., based on 5-tuple

    except Scapy_Exception as se:
        logger.error(f"Packet {packet_number}: Scapy error during feature extraction: {se}")
        # Return partially extracted features or None depending on severity
        return features # Return what we have so far
    except Exception as e:
        logger.error(f"Packet {packet_number}: Unexpected error extracting features: {e}", exc_info=True)
        return None # Indicate failure to extract

    # logger.debug(f"Extracted features for packet {packet_number}: {features}")
    return features


# --- Helper: Generate Flow ID (Example) ---
# def generate_flow_id(features: Dict[str, Any]) -> Optional[str]:
#     """Generates a 5-tuple flow ID."""
#     protocol = features.get("protocol")
#     src_ip = features.get("src_ip")
#     dst_ip = features.get("dst_ip")
#     src_port = features.get("src_port")
#     dst_port = features.get("dst_port")
#
#     if not all([protocol, src_ip, dst_ip]):
#         return None # Need base IP info
#
#     # Ensure consistent order (lower IP/Port first)
#     if (src_ip, src_port) > (dst_ip, dst_port):
#         src_ip, dst_ip = dst_ip, src_ip
#         src_port, dst_port = dst_port, src_port
#
#     return f"{protocol}_{src_ip}_{src_port}_{dst_ip}_{dst_port}"
